# sort #

对`插入排序`、`快速排序`、`堆排序`、`归并排序`进行了比较。比较结果如下：


	n           插入排序      	快速排序      堆排序			归并排序
	10       	1.00us			2.00us		2.00us			7.00us
	20  		3.00us			2.00us		3.00us			3.00us
	30  		6.00us			4.00us		4.00us			4.00us
	40  		10.00us 		5.00us		6.00us			5.00us
	50 			16.00us			6.00us		17.00us			6.00us
	60  		28.00us			8.00us		11.00us			7.00us
	70  		36.00us			9.00us		12.00us			9.00us
	80  		9.00us			10.00us		14.00us			9.00us
	90  		50.00us			11.00us		17.00us			11.00us
	100  		62.00us			13.00us		19.00us			11.00us
	200 		247.00us		38.00us		40.00us			28.00us
	300 		572.00us		137.00us	66.00us			39.00us
	400 		1000.00us		72.00us		98.00us			50.00us
	500 		1548.00us		80.00us		119.00us		62.00us
	600 		2218.00us		95.00us		146.00us		73.00us
	700 		3009.00us		115.00us	171.00us		86.00us
	800  		3943.00us		138.00us	203.00us		100.00us
	900  		4966.00us		149.00us	234.00us		112.00us
	1000 		6148.00us		183.00us	259.00us		124.00us
	1500  		13774.00us		464.00us
	2000  		24315.00us		561.00us
	3000  		54099.00us		1020.00us
	4000  		94869.00us		1760.00us
	5000  		139334.00us		2041.00us
	10000  		555746.00us		24722.00us


# 说明 #

1. 对于快速排序，采用`3值取中法`来带到基准元素。
2. 对于以上四种排序方法，都应该使用每种算法最坏情况下的测试数据。

# 总结 #

没有一种排序方式是最好的，有些方法适合n较小的情况，而另一些方法适合n较大的情况。当输入序列部分有序
时，**插入排序**可以很好的工作。且由于这种方法的额外空间开销比较低，所以当n比较小时，插入排序是最好的
方法。
如果考察排序算法在最坏情况下的性能，**归并排序**是最好的。但归并排序比堆排序的空间开销更大，也比快速
排序的空间开销稍大一些。如果考虑排序算法的平均时间性能，**快速排序**是最好的。


从上面的表格可以看出，我们在实际应用中，可以将以上几种排序算法组合起来使用。比如： 在归并排序中
使用快速排序来处理长度小于45的子序列，在快速排序中使用插入排序来处理长度小于20的子序列。