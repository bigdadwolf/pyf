\input texinfo @c -*-texinfo-*-

@c %**start of header
@setfilename multiboot.info
@documentencoding UTF-8
@include version.texi
@settitle Multiboot Specification version @value{VERSION}
@c Unify all our little indices for now.
@syncodeindex fn cp
@syncodeindex vr cp
@syncodeindex ky cp
@syncodeindex pg cp
@syncodeindex tp cp
@c %**end of header

@footnotestyle separate
@paragraphindent 3
@finalout

@c %** start of copying
@copying
Copyright @copyright{} 1995,96 Bryan Ford <baford@@cs.utah.edu>

Copyright @copyright{} 1995,96 Erich Stefan Boleyn <erich@@uruk.org>

Copyright @copyright{} 1999,2000,2001,2002,2005,2006,2009,2010 Free Software Foundation, Inc.

@quotation
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).
@end ignore

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified
versions.
@end quotation
@end copying
@c %** end of copying

@dircategory Kernel

@direntry
* Multiboot Specification: (multiboot).		Multiboot Specification.
@end direntry

@titlepage
@sp 10
@c @title The Multiboot Specification version @value{VERSION}
@title  Multiboot 规范  @value{VERSION}
@author Yoshinori K. Okuji, Bryan Ford, Erich Stefan Boleyn, Kunihiro Ishiguro
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@finalout
@headings double

@ifnottex
@node Top
@top Multiboot Specification

This file documents Multiboot Specification, the proposal for the boot
sequence standard. This edition documents version @value{VERSION}.

本文定义了Multiboot规范——引导过程标准的提议。本文是此规范的@value{VERSION}版。

@insertcopying
@end ifnottex

@menu
* Overview::                    
* Terminology::                 
* Specification::               
* Examples::                    
* History::
* Invoking mbchk::              How to use the Multiboot checker
* Index::                  
@end menu


@node Overview
@chapter Introduction to Multiboot Specification

This chapter describes some rough information on the Multiboot
Specification. Note that this is not a part of the specification itself.

本章描述了一些Multiboot规范的粗略信息。注意，这不是规范本身的一部分。

@menu
* Motivation::                  
* Architecture::                
* Operating systems::           
* Boot sources::                
* Boot-time configuration::     
* Convenience to operating systems::  
* Boot modules::                
@end menu


@node Motivation
@section The background of Multiboot Specification

Every operating system ever created tends to have its own boot loader.
Installing a new operating system on a machine generally involves
installing a whole new set of boot mechanisms, each with completely
different install-time and boot-time user interfaces. Getting multiple
operating systems to coexist reliably on one machine through typical
@dfn{chaining} mechanisms can be a nightmare. There is little or no
choice of boot loaders for a particular operating system --- if the one
that comes with the operating system doesn't do exactly what you want,
or doesn't work on your machine, you're screwed.

几乎每种现有的操作系统都拥有自己的引导程序。在机器上安装一个新的操作系统
时通常意味着要引入一套全新的引导机制，每种机制安装和运行界面都不相同。
使多种操作系统相安无事地共存于一个机器上通常需要借助于@dfn{链式}机制，这可是一个
噩梦。基本上你不能选择某一个操作系统的引导程序————如果操作系统自带的引导程序
不是你想要的，或者不能在你的机器上工作，你的麻烦可就大了。


While we may not be able to fix this problem in existing proprietary
operating systems, it shouldn't be too difficult for a few people in the
free operating system communities to put their heads together and solve
this problem for the popular free operating systems. That's what this
specification aims for. Basically, it specifies an interface between a
boot loader and a operating system, such that any complying boot loader
should be able to load any complying operating system. This
specification does @emph{not} specify how boot loaders should work ---
only how they must interface with the operating system being loaded.

尽管不太可能解决现有的商业操作系统所存在的问题，但是对于自由操作系统社区
的人来说，将他们的领袖集合在一起并为流行的自由操作系统解决这个问题并不是
很难。这也正是这份规范的目的所在。基本上，它指出了引导程序和操作系统之间
的接口，这样符合规范的引导程序就可以引导任何符合规范的操作系统。这份规范
并@emph{不}关心引导程序应该如何工作————只是关心他们引导操作系统时的接口。

@node Architecture
@c 架构
@section The target architecture

This specification is primarily targeted at @sc{pc}, since they are the
most common and have the largest variety of operating systems and boot
loaders. However, to the extent that certain other architectures may
need a boot specification and do not have one already, a variation of
this specification, stripped of the x86-specific details, could be
adopted for them as well.

这份规范主要面向@sc{pc}，因为他们使用最广泛并且有最多的操作系统和引导程序。
尽管如此，对于那些需要一份引导规范并且目前缺少一份的架构来说，剥去x86架构
的相关细节得到的版本也应该可以满足需要。

@node Operating systems
@c 操作系统
@section The target operating systems

This specification is targeted toward free 32-bit operating systems
that can be fairly easily modified to support the specification without
going through lots of bureaucratic rigmarole. The particular free
operating systems that this specification is being primarily designed
for are Linux, the kernels of FreeBSD and NetBSD, Mach, and VSTa. It is hoped that other
emerging free operating systems will adopt it from the start, and thus
immediately be able to take advantage of existing boot loaders. It would
be nice if proprietary operating system vendors eventually adopted this
specification as well, but that's probably a pipe dream.

这份规范的目标是自由的32位操作系统，因为应该可以比较容易获得修改这些
操作系统以支持本规范的权力而不需要听满是官腔的喋喋不休。这份规范主要
是面向Linux——FreeBSD、NetBSD、Mach和VSTa这些自由操作系统的内核而设计的。
我们希望后来的自由操作系统能够从一开始就采用本规范，这样就可以立即使
用现有的引导程序了。如果商业操作系统能够最终采用本规范当然很好，但是
这很可能只是白日做梦。

@node Boot sources
@section Boot sources

It should be possible to write compliant boot loaders that load the OS
image from a variety of sources, including floppy disk, hard disk, and
across a network.

实现一个可以从各种位置（软盘、硬盘或网络）载入OS映像的引导程序是现实可行的。


Disk-based boot loaders may use a variety of techniques to find the
relevant OS image and boot module data on disk, such as by
interpretation of specific file systems (e.g. the BSD/Mach boot loader),
using precalculated @dfn{blocklists} (e.g. LILO), loading from a
special @dfn{boot partition} (e.g. OS/2), or even loading from within
another operating system (e.g. the VSTa boot code, which loads from
DOS). Similarly, network-based boot loaders could use a variety of
network hardware and protocols.

基于磁盘的引导程序可以使用各种技术查找位于磁盘上的OS映像和引导模块，
例如解释某种文件系统（如BSD/Mach引导程序），使用预先计算好的@dfn{block列表}
（如LILO），从特殊的@dfn{引导分区}载入（如OS/2），或者甚至从另一个操作系统
载入（如VSTa引导代码，从DOS载入）。与此相似，基于网络的引导程序也可以
使用各种网络硬件和协议。

It is hoped that boot loaders will be created that support multiple
loading mechanisms, increasing their portability, robustness, and
user-friendliness.

我们希望引导程序可以支持多种载入机制，这样可以提供更好的可移植性、
健壮性和易用性。

@node Boot-time configuration
@section Configure an operating system at boot-time

It is often necessary for one reason or another for the user to be able
to provide some configuration information to an operating system
dynamically at boot time. While this specification should not dictate
how this configuration information is obtained by the boot loader, it
should provide a standard means for the boot loader to pass such
information to the operating system.

总有这样或者那样的原因使得用户需要在启动时动态配置操作系统。尽管本规范
不应该对引导程序如何获得这些配置信息指手划脚，我们还是应该为如何将这些
信息传递给操作系统提供一种标准的方法。


@node Convenience to operating systems
@section How to make OS development easier

OS images should be easy to generate. Ideally, an OS image should simply
be an ordinary 32-bit executable file in whatever file format the
operating system normally uses. It should be possible to @code{nm} or
disassemble OS images just like normal executables. Specialized tools
should not be required to create OS images in a @emph{special} file
format. If this means shifting some work from the operating system to
a boot loader, that is probably appropriate, because all the memory
consumed by the boot loader will typically be made available again after
the boot process is created, whereas every bit of code in the OS image
typically has to remain in memory forever. The operating system should
not have to worry about getting into 32-bit mode initially, because mode
switching code generally needs to be in the boot loader anyway in order
to load operating system data above the 1MB boundary, and forcing the
operating system to do this makes creation of OS images much more
difficult.

应尽量降低生成OS映像的难度。在理想情况下，OS映像应该是该操作系统通常使用的
普通32位可执行文件格式。应该能够像对待普通可执行文件格式一样用@code{nm}
或者反汇编OS映像，而不应该用特殊的工具生成@emph{特殊}文件格式的OS映像。
如果者意味着将一部分的操作系统的功能转移到引导程序中的话，这很合适。因为
任何引导程序用到的内存都应该可由它所创建的真正的系统自由使用，这样OS映像中
的每一个比特都应该永远存在于内存中。操作系统应该不必考虑如何进入32位地址
模式，因为模式切换应该位于引导程序中，而这些程序通常需要将操作系统数据
装入到1MB以上的内存中，如果操作系统需要考虑这些问题的话，创建OS映像的工作
将会变得更加困难。

Unfortunately, there is a horrendous variety of executable file formats
even among free Unix-like @sc{pc}-based operating systems --- generally
a different format for each operating system. Most of the relevant free
operating systems use some variant of a.out format, but some are moving
to @sc{elf}. It is highly desirable for boot loaders not to have to be
able to interpret all the different types of executable file formats in
existence in order to load the OS image --- otherwise the boot loader
effectively becomes operating system specific again.

不幸的是，仅在@sc{pc}平台上的自由UNIX类系统中也有多得惊人的可执行文件格式
——通常各种操作系统的格式都不相同。大多数自由操作系统使用的是a.out格式的
变种，但是有一些已经改用了@sc{elf}格式。最好是引导程序不必为了载入OS映像
而需要理解所有的可执行文件格式——否则的话，引导程序又变成了某个操作系统
专用的了。

This specification adopts a compromise solution to this
problem. Multiboot-compliant OS images always contain a magic
@dfn{Multiboot header} (@pxref{OS image format}), which allows the boot
loader to load the image without having to understand numerous a.out
variants or other executable formats. This magic header does not need to
be at the very beginning of the executable file, so kernel images can
still conform to the local a.out format variant in addition to being
Multiboot-compliant.

这份规范采用一种折衷的方案。符合Multiboot规范的OS映象总是包含一个magic 
@dfn{ Multiboot头}（参见@pxref{OS image format}），这样引导程序就不必理解种类繁多的
a.out变体或者其他什么可执行格式。magic头不必位于可执行文件的最前面，这样
OS 映象就可以在保持同a.out格式兼容的同时做到符合Multiboot规范。

@node Boot modules
@section Boot modules

Many modern operating system kernels, such as Mach and the microkernel in VSTa, do
not by themselves contain enough mechanism to get the system fully
operational: they require the presence of additional software modules at
boot time in order to access devices, mount file systems, etc. While
these additional modules could be embedded in the main OS image along
with the kernel itself, and the resulting image be split apart manually
by the operating system when it receives control, it is often more
flexible, more space-efficient, and more convenient to the operating
system and user if the boot loader can load these additional modules
independently in the first place.

Thus, this specification should provide a standard method for a boot
loader to indicate to the operating system what auxiliary boot modules
were loaded, and where they can be found. Boot loaders don't have to
support multiple boot modules, but they are strongly encouraged to,
because some operating systems will be unable to boot without them.


@node Terminology
@chapter The definitions of terms used through the specification

@table @dfn
@item must
We use the term @dfn{must}, when any boot loader or OS image needs to
follow a rule --- otherwise, the boot loader or OS image is @emph{not}
Multiboot-compliant.

必须

术语@dfn{必须}表示引导程序或OS映像需要服从某一规则，否则的话，引导程序或者OS
映像就@emph{不}能称为符合Multiboot规范的。

@item should
We use the term @dfn{should}, when any boot loader or OS image is
recommended to follow a rule, but it doesn't need to follow the rule.

应该

术语@dfn{应该}表示引导程序或OS映像最好服从某一规则，但如果没有服从也是可以的。

@item may
We use the term @dfn{may}, when any boot loader or OS image is allowed
to follow a rule.

可以

术语@dfn{可以}引导程序或OS映像服从某一规则是允许的。

@item boot loader
Whatever program or set of programs loads the image of the final
operating system to be run on the machine. The boot loader may itself
consist of several stages, but that is an implementation detail not
relevant to this specification. Only the @emph{final} stage of the boot
loader --- the stage that eventually transfers control to an operating
system --- must follow the rules specified in this document in order
to be @dfn{Multiboot-compliant}; earlier boot loader stages may be
designed in whatever way is most convenient.

引导程序

引导程序是负责载入最终的操作系统映像的一个或一组程序。引导程序本身可以由
几个阶段组成，但是这属于实现细节而同本规范无关。只有引导程序@emph{最后}的
阶段——最终将控制权转交给操作系统的阶段——必须遵守本文中规定的规则，否则引导
程序就不能称为符合Multiboot规范； 在这之前的阶段可以怎么方便怎么设计。

@item OS image
The initial binary image that a boot loader loads into memory and
transfers control to start an operating system. The OS image is
typically an executable containing the operating system kernel.

OS映像

OS映像是引导程序载入到内存的初始二进制映像，随后引导程序会将控制权转
移给它，这样就启动了操作系统。典型的OS映像是包含了操作系统内核的可
执行文件。

@item boot module
Other auxiliary files that a boot loader loads into memory along with
an OS image, but does not interpret in any way other than passing their
locations to the operating system when it is invoked.

引导模块

引导模块是由引导程序同OS映像一同载入的其他起辅助作用的文件。引导程序
并不理解这些文件，只会将它们的位置告知操作系统。

@item Multiboot-compliant
A boot loader or an OS image which follows the rules defined as
@dfn{must} is Multiboot-compliant. When this specification specifies a
rule as @dfn{should} or @dfn{may}, a Multiboot-complaint boot loader/OS
image doesn't need to follow the rule.

符合Multiboot规范

服从所有被标记为@dfn{必须}的引导程序或者OS映像被称为符合Multiboot规范。
对于规范中那些被标记为@dfn{应该}或者@dfn{可以}的规则，符合Multiboot规范
的引导程序或OS映像可以不必遵守。

@item u8
The type of unsigned 8-bit data.

无符号8位数据。

@item u16
The type of unsigned 16-bit data. Because the target architecture is
little-endian, u16 is coded in little-endian.

无符号16位数据。因为目标架构是高位优先（little-endian）的，所以u16按照高位优先编码。

@item u32
The type of unsigned 32-bit data. Because the target architecture is
little-endian, u32 is coded in little-endian.

无符号32位数据。因为目标架构是高位优先（little-endian）的，所以u32按照高位优先编码。

@item u64
The type of unsigned 64-bit data. Because the target architecture is
little-endian, u64 is coded in little-endian.

无符号64位数据。因为目标架构是高位优先（little-endian）的，所以u64按照高位优先编码。

@end table


@node Specification
@chapter The exact definitions of Multiboot Specification

There are three main aspects of a boot loader/OS image interface:

引导程序/OS映像接口主要包括三个方面：

@enumerate
@item
The format of an OS image as seen by a boot loader.

引导程序看到OS映像的格式。

@item
The state of a machine when a boot loader starts an operating
system.

当引导程序启动操作系统时机器的状态。

@item
The format of information passed by a boot loader to an operating
system.

引导程序传递给操作系统的信息的格式。
@end enumerate

@menu
* OS image format::             
* Machine state::               
* Boot information format::     
@end menu


@node OS image format
@section OS image format

An OS image may be an ordinary 32-bit executable file in the standard
format for that particular operating system, except that it may be
linked at a non-default load address to avoid loading on top of the
@sc{pc}'s I/O region or other reserved areas, and of course it should
not use shared libraries or other fancy features.

一个OS映像可以是一个普通的某种操作系统使用的标准格式的32位可执行文件，
不同之处是它可能被链接到一个非默认的载入地址以避开@sc{pc}的I/O区域或者
其它保留区域，当然它也不能使用共享库或者其它这样可爱的东西。

An OS image must contain an additional header called @dfn{Multiboot
header}, besides the headers of the format used by the OS image. The
Multiboot header must be contained completely within the first 8192
bytes of the OS image, and must be longword (32-bit) aligned. In
general, it should come @emph{as early as possible}, and may be
embedded in the beginning of the text segment after the @emph{real}
executable header.

除了OS映像所使用的格式需要的头之外，OS映像还需要额外包括一个@dfn{Multiboot头}，
Multiboot头必须完整的包含在OS映像的前8192字节内，并且必须是32位
对齐的。通常来说，它的位置@emph{越靠前越好}，并且可以嵌入在text
段的起始处，位于可执行文件头之后。
@menu
* Header layout::               The layout of Multiboot header
* Header magic fields::         The magic fields of Multiboot header
* Header address fields::       
* Header graphics fields::      
@end menu


@node Header layout
@subsection The layout of Multiboot header

The layout of the Multiboot header must be as follows:

Multiboot的头分布必须如下表所示：

@multitable @columnfractions .1 .1 .2 .5
@item 偏移量 @tab 类型  @tab 域名    @tab 备注
@item 0      @tab u32 @tab magic         @tab 必须
@item 4      @tab u32 @tab flags         @tab 必须
@item 8      @tab u32 @tab checksum      @tab 必须
@item 12     @tab u32 @tab header_addr   @tab 如果 flags[16] 被置位
@item 16     @tab u32 @tab load_addr     @tab 如果 flags[16] 被置位
@item 20     @tab u32 @tab load_end_addr @tab 如果 flags[16] 被置位
@item 24     @tab u32 @tab bss_end_addr  @tab 如果 flags[16] 被置位
@item 28     @tab u32 @tab entry_addr    @tab 如果 flags[16] 被置位
@item 32     @tab u32 @tab mode_type     @tab 如果 flags[2] 被置位
@item 36     @tab u32 @tab width         @tab 如果 flags[2] 被置位
@item 40     @tab u32 @tab height        @tab 如果 flags[2] 被置位
@item 44     @tab u32 @tab depth         @tab 如果 flags[2] 被置位
@end multitable

@multitable @columnfractions .1 .1 .2 .5
@item Offset @tab Type  @tab Field Name    @tab Note
@item 0      @tab u32 @tab magic         @tab required
@item 4      @tab u32 @tab flags         @tab required
@item 8      @tab u32 @tab checksum      @tab required
@item 12     @tab u32 @tab header_addr   @tab if flags[16] is set
@item 16     @tab u32 @tab load_addr     @tab if flags[16] is set
@item 20     @tab u32 @tab load_end_addr @tab if flags[16] is set
@item 24     @tab u32 @tab bss_end_addr  @tab if flags[16] is set
@item 28     @tab u32 @tab entry_addr    @tab if flags[16] is set
@item 32     @tab u32 @tab mode_type     @tab if flags[2] is set
@item 36     @tab u32 @tab width         @tab if flags[2] is set
@item 40     @tab u32 @tab height        @tab if flags[2] is set
@item 44     @tab u32 @tab depth         @tab if flags[2] is set
@end multitable

@samp{magic}, @samp{flags} 和 @samp{checksum} 域在@ref{Header magic fields}中定义,
@samp{header_addr},@samp{load_addr}, @samp{load_end_addr}, @samp{bss_end_addr} 和
@samp{entry_addr}域在 @ref{Header address fields}中定义, @samp{mode_type}, @samp{width},
@samp{height} 和 @samp{depth} 在 @ref{Header graphics fields}中定义。

The fields @samp{magic}, @samp{flags} and @samp{checksum} are defined in
@ref{Header magic fields}, the fields @samp{header_addr},
@samp{load_addr}, @samp{load_end_addr}, @samp{bss_end_addr} and
@samp{entry_addr} are defined in @ref{Header address fields}, and the
fields @samp{mode_type}, @samp{width}, @samp{height} and @samp{depth} are
defined in @ref{Header graphics fields}.


@node Header magic fields
@subsection The magic fields of Multiboot header

@table @samp
@item magic
The field @samp{magic} is the magic number identifying the header,
which must be the hexadecimal value @code{0x1BADB002}.

@samp{magic}域是标志头的魔数，它必须等于十六进制值0x1BADB002。

@item flags
The field @samp{flags} specifies features that the OS image requests or
requires of an boot loader. Bits 0-15 indicate requirements; if the
boot loader sees any of these bits set but doesn't understand the flag
or can't fulfill the requirements it indicates for some reason, it must
notify the user and fail to load the OS image. Bits 16-31 indicate
optional features; if any bits in this range are set but the boot loader
doesn't understand them, it may simply ignore them and proceed as
usual. Naturally, all as-yet-undefined bits in the @samp{flags} word
must be set to zero in OS images. This way, the @samp{flags} fields
serves for version control as well as simple feature selection.

@samp{flags}域指出OS映像需要引导程序提供或支持的特性。
0-15位指出需求：如果引导程序发现某些位被设置但出于某种原因不理解或
不能满足相应的需求，它必须告知用户并宣告引导失败。
16-31位指出可选的特性：如果引导程序不能支持某些位，它可以简单的忽略它们并正常引导。
自然，所有@samp{flags}字中尚未定义的位必须被置为0。这样，@samp{flags}域既可以用于版本控制
也可以用于简单的特性选择。 


If bit 0 in the @samp{flags} word is set, then all boot modules loaded
along with the operating system must be aligned on page (4KB)
boundaries. Some operating systems expect to be able to map the pages
containing boot modules directly into a paged address space during
startup, and thus need the boot modules to be page-aligned.

如果设置了@samp{flags}字中的0位，所有的引导模块将按页（4KB）边界对齐。
有些操作系统能够在启动时将包含引导模块的页直接映射到一个分页的地址空间，
因此需要引导模块是页对齐的。

If bit 1 in the @samp{flags} word is set, then information on available
memory via at least the @samp{mem_*} fields of the Multiboot information
structure (@pxref{Boot information format}) must be included. If the
boot loader is capable of passing a memory map (the @samp{mmap_*} fields)
and one exists, then it may be included as well.

如果设置了@samp{flags}字中的1位，则必须通过Multiboot信息结构
(@pxref{Boot information format}）的@samp{mem_*}域包括可用内存的信息。
如果引导程序能够传递内存分布（@samp{mmap_*} 域）并且它确实存在，则也包括它。


If bit 2 in the @samp{flags} word is set, information about the video
mode table (@pxref{Boot information format}) must be available to the
kernel.

如果设置了flags字中的2位，有关视频模式表（@pxref{Boot information format}）
的信息必须对内核可见。


If bit 16 in the @samp{flags} word is set, then the fields at offsets
12-28 in the Multiboot header are valid, and the boot loader should use
them instead of the fields in the actual executable header to calculate
where to load the OS image. This information does not need to be
provided if the kernel image is in @sc{elf} format, but it @emph{must}
be provided if the images is in a.out format or in some other
format. Compliant boot loaders must be able to load images that either
are in @sc{elf} format or contain the load address information embedded
in the Multiboot header; they may also directly support other executable
formats, such as particular a.out variants, but are not required to.

如果设置了 @samp{flags}字中的16位，则Multiboot头中偏移量8-28的域有效，
引导程序应该使用它们而不是实际可执行头中的域来计算将OS映象载入到的位置。
如果内核映象为@sc{elf}格式则不必提供这样的信息，但是如果映象是a.out格式或者
其他什么格式的话就@emph{必须}提供这些信息。兼容的引导程序必须既能够载入@sc{elf}
格式的映象也能载入将载入地址信息嵌入Multiboot头中的映象；
它们也可以直接支持其他的可执行格式，例如一个a.out的特殊变体，但这不是必须的。

@item checksum
The field @samp{checksum} is a 32-bit unsigned value which, when added
to the other magic fields (i.e. @samp{magic} and @samp{flags}), must
have a 32-bit unsigned sum of zero.

域@samp{checksum}是一个32位的无符号值，当与其他的magic域（也就是
@samp{magic}和@samp{flags}）相加时，结果必须是32位的无符号值0
（即@samp{magic} + @samp{flags} + @samp{checksum} = 0）。
@end table


@node Header address fields
@subsection The address fields of Multiboot header

All of the address fields enabled by flag bit 16 are physical addresses.
The meaning of each is as follows:

@table @code
@item header_addr
Contains the address corresponding to the beginning of the Multiboot
header --- the physical memory location at which the magic value is
supposed to be loaded. This field serves to @dfn{synchronize} the
mapping between OS image offsets and physical memory addresses.

@item load_addr
Contains the physical address of the beginning of the text segment. The
offset in the OS image file at which to start loading is defined by the
offset at which the header was found, minus (header_addr -
load_addr). load_addr must be less than or equal to header_addr.

@item load_end_addr
Contains the physical address of the end of the data
segment. (load_end_addr - load_addr) specifies how much data to load.
This implies that the text and data segments must be consecutive in the
OS image; this is true for existing a.out executable formats.
If this field is zero, the boot loader assumes that the text and data
segments occupy the whole OS image file.

@item bss_end_addr
Contains the physical address of the end of the bss segment. The boot
loader initializes this area to zero, and reserves the memory it
occupies to avoid placing boot modules and other data relevant to the
operating system in that area. If this field is zero, the boot loader
assumes that no bss segment is present.

@item entry_addr
The physical address to which the boot loader should jump in order to
start running the operating system.
@end table


@node Header graphics fields
@subsection The graphics fields of Multiboot header

All of the graphics fields are enabled by flag bit 2. They specify the
preferred graphics mode. Note that that is only a @emph{recommended}
mode by the OS image. Boot loader may choose a different mode if it sees fit.

The meaning of each is as follows:

@table @code
@item mode_type
Contains @samp{0} for linear graphics mode or @samp{1} for
EGA-standard text mode. Everything else is reserved for future
expansion. Note that the boot loader may set a text mode even if this
field contains @samp{0}, or set a video mode even if this field contains
@samp{1}.

@item width
Contains the number of the columns. This is specified in pixels in a
graphics mode, and in characters in a text mode. The value zero
indicates that the OS image has no preference.

@item height
Contains the number of the lines. This is specified in pixels in a
graphics mode, and in characters in a text mode. The value zero
indicates that the OS image has no preference.

@item depth
Contains the number of bits per pixel in a graphics mode, and zero in
a text mode. The value zero indicates that the OS image has no
preference.
@end table


@node Machine state
@section Machine state

When the boot loader invokes the 32-bit operating system, the machine
must have the following state:

@table @samp
@item EAX
Must contain the magic value @samp{0x2BADB002}; the presence of this
value indicates to the operating system that it was loaded by a
Multiboot-compliant boot loader (e.g. as opposed to another type of
boot loader that the operating system can also be loaded from).

@item EBX
Must contain the 32-bit physical address of the Multiboot
information structure provided by the boot loader (@pxref{Boot
information format}).

@item CS
Must be a 32-bit read/execute code segment with an offset of @samp{0}
and a limit of @samp{0xFFFFFFFF}. The exact value is undefined.

@item DS
@itemx ES
@itemx FS
@itemx GS
@itemx SS
Must be a 32-bit read/write data segment with an offset of @samp{0}
and a limit of @samp{0xFFFFFFFF}. The exact values are all undefined.

@item A20 gate
Must be enabled.

@item CR0
Bit 31 (PG) must be cleared. Bit 0 (PE) must be set. Other bits are
all undefined.

@item EFLAGS
Bit 17 (VM) must be cleared. Bit 9 (IF) must be cleared. Other bits
are all undefined.
@end table

All other processor registers and flag bits are undefined. This
includes, in particular:

@table @samp
@item ESP
The OS image must create its own stack as soon as it needs one.

@item GDTR
Even though the segment registers are set up as described above, the
@samp{GDTR} may be invalid, so the OS image must not load any segment
registers (even just reloading the same values!) until it sets up its
own @samp{GDT}.

@item IDTR
The OS image must leave interrupts disabled until it sets up its own
@code{IDT}.
@end table

However, other machine state should be left by the boot loader in
@dfn{normal working order}, i.e. as initialized by the @sc{bios} (or
DOS, if that's what the boot loader runs from). In other words, the
operating system should be able to make @sc{bios} calls and such after
being loaded, as long as it does not overwrite the @sc{bios} data
structures before doing so. Also, the boot loader must leave the
@sc{pic} programmed with the normal @sc{bios}/DOS values, even if it
changed them during the switch to 32-bit mode.


@node Boot information format
@section Boot information format

FIXME: Split this chapter like the chapter ``OS image format''.

FIXME: 将这章像 ``OS image format''那样分解。

Upon entry to the operating system, the @code{EBX} register contains the
physical address of a @dfn{Multiboot information} data structure,
through which the boot loader communicates vital information to the
operating system. The operating system can use or ignore any parts of
the structure as it chooses; all information passed by the boot loader
is advisory only.

在进入操作系统之前，@code{EBX} 寄存器包含了@dfn{Multiboot information}
数据结构的物理地址，引导程序通过它将重要的引导信息传递给操作系统。
操作系统可以按照自己的需要使用或者忽略任何部分；所有的引导程序传递的
信息只是建议性的。

The Multiboot information structure and its related substructures may be
placed anywhere in memory by the boot loader (with the exception of the
memory reserved for the kernel and boot modules, of course). It is the
operating system's responsibility to avoid overwriting this memory until
it is done using it.

Multiboot信息结构和它的相关的子结构可以由引导程序放在任何位置（当然，除了
保留给内核和引导模块的区域）。如何在利用该信息前保护它是操作系统的责任。

The format of the Multiboot information structure (as defined so far)
follows:

Multiboot信息结构的格式（就目前为止定义的）如下：

@example
@group
        +-------------------+
0       | flags             |    (必须)
        +-------------------+
4       | mem_lower         |    (如果flags[0]被置位则出现)
8       | mem_upper         |    (如果flags[0]被置位则出现)
        +-------------------+
12      | boot_device       |    (如果flags[1]被置位则出现)
        +-------------------+
16      | cmdline           |    (如果flags[1]被置位则出现)
        +-------------------+
20      | mods_count        |    (如果flags[1]被置位则出现)
24      | mods_addr         |    (如果flags[1]被置位则出现)
        +-------------------+
28 - 40 | syms              |    (如果flags[4] 或
        |                   |                flags[5]被置位则出现)
        +-------------------+
44      | mmap_length       |    (如果flags[6]被置位则出现)
48      | mmap_addr         |    (如果flags[6]被置位则出现)
        +-------------------+
52      | drives_length     |    (如果flags[7]被置位则出现)
56      | drives_addr       |    (如果flags[7]被置位则出现)
        +-------------------+
60      | config_table      |    (如果flags[8]被置位则出现)
        +-------------------+
64      | boot_loader_name  |    (如果flags[9]被置位则出现)
        +-------------------+
68      | apm_table         |    (如果flags[10]被置位则出现)
        +-------------------+
72      | vbe_control_info  |    (如果flags[11]被置位则出现)
76      | vbe_mode_info     |
80      | vbe_mode          |
82      | vbe_interface_seg |
84      | vbe_interface_off |
86      | vbe_interface_len |
        +-------------------+
88      | framebuffer_addr  |    (如果flags[12]被置位则出现)
96      | framebuffer_pitch |
100     | framebuffer_width |
104     | framebuffer_height|
108     | framebuffer_bpp   |
109     | framebuffer_type  |
110-115 | color_info        |
        +-------------------+

@end group
@end example

@example
@group
        +-------------------+
0       | flags             |    (required)
        +-------------------+
4       | mem_lower         |    (present if flags[0] is set)
8       | mem_upper         |    (present if flags[0] is set)
        +-------------------+
12      | boot_device       |    (present if flags[1] is set)
        +-------------------+
16      | cmdline           |    (present if flags[2] is set)
        +-------------------+
20      | mods_count        |    (present if flags[3] is set)
24      | mods_addr         |    (present if flags[3] is set)
        +-------------------+
28 - 40 | syms              |    (present if flags[4] or
        |                   |                flags[5] is set)
        +-------------------+
44      | mmap_length       |    (present if flags[6] is set)
48      | mmap_addr         |    (present if flags[6] is set)
        +-------------------+
52      | drives_length     |    (present if flags[7] is set)
56      | drives_addr       |    (present if flags[7] is set)
        +-------------------+
60      | config_table      |    (present if flags[8] is set)
        +-------------------+
64      | boot_loader_name  |    (present if flags[9] is set)
        +-------------------+
68      | apm_table         |    (present if flags[10] is set)
        +-------------------+
72      | vbe_control_info  |    (present if flags[11] is set)
76      | vbe_mode_info     |
80      | vbe_mode          |
82      | vbe_interface_seg |
84      | vbe_interface_off |
86      | vbe_interface_len |
        +-------------------+
88      | framebuffer_addr  |    (present if flags[12] is set)
96      | framebuffer_pitch |
100     | framebuffer_width |
104     | framebuffer_height|
108     | framebuffer_bpp   |
109     | framebuffer_type  |
110-115 | color_info        |
        +-------------------+

@end group
@end example

The first longword indicates the presence and validity of other fields
in the Multiboot information structure. All as-yet-undefined bits must
be set to zero by the boot loader. Any set bits that the operating
system does not understand should be ignored. Thus, the @samp{flags}
field also functions as a version indicator, allowing the Multiboot
information structure to be expanded in the future without breaking
anything.

第一个longword指出Multiboot信息结构中的其它域是否有效。所有目前未定义
的位必须被引导程序设为0。操作系统应该忽略任何它不理解的位。因此，@samp{flags}
域也可以视作一个版本标志符，这样在将来可以无破坏的扩展Multiboot信息结构。


If bit 0 in the @samp{flags} word is set, then the @samp{mem_*} fields
are valid. @samp{mem_lower} and @samp{mem_upper} indicate the amount of
lower and upper memory, respectively, in kilobytes. Lower memory starts
at address 0, and upper memory starts at address 1 megabyte. The maximum
possible value for lower memory is 640 kilobytes. The value returned for
upper memory is maximally the address of the first upper memory hole
minus 1 megabyte. It is not guaranteed to be this value.

如果设置了flags中的第0位，则mem_*域有效。mem_lower和mem_upper分别指出了
低端和高端内存的大小，单位是Kb。低端内存的首地址是0，高端内存的首地址是
1M。低端内存的最大可能值是640Kb。返回的高端内存的最大可能值是最大值减去
1M，但并不保证是这个值。

If bit 1 in the @samp{flags} word is set, then the @samp{boot_device}
field is valid, and indicates which @sc{bios} disk device the boot
loader loaded the OS image from. If the OS image was not loaded from a
@sc{bios} disk, then this field must not be present (bit 3 must be
clear). The operating system may use this field as a hint for
determining its own @dfn{root} device, but is not required to. The
@samp{boot_device} field is laid out in four one-byte subfields as
follows:

如果设置了flags中的第1位，则boot_device域有效，并指出引导程序从哪个
BIOS磁盘载入OS镜像。如果OS镜像不是从一个BIOS磁盘载入的，这个域就不能
出现（第3位必须设置为0）。操作系统可以使用这个域帮助确定它的root设备，
但并不一定要这么做。boot_device由四个单字节的子域组成：

@example
@group
+-------+-------+-------+-------+
| part3 | part2 | part1 | drive |
+-------+-------+-------+-------+
Least significant             Most significant
@end group
@end example

The most significant byte contains the @sc{bios} drive number
as understood by the
@sc{bios} INT 0x13 low-level disk interface: e.g. 0x00 for the first
floppy disk or 0x80 for the first hard disk.

第一个字节（最高有效字节）包含了bios驱动器号，它的格式与bios的INT 0x13低级磁盘接口相同：
例如，0x00代表第一个软盘驱动器，0x80代表第一个硬盘驱动器。


The three remaining bytes specify the boot partition. @samp{part1}
specifies the @dfn{top-level} partition number, @samp{part2} specifies a
@dfn{sub-partition} in the top-level partition, etc. Partition numbers
always start from zero. Unused partition bytes must be set to 0xFF. For
example, if the disk is partitioned using a simple one-level DOS
partitioning scheme, then @samp{part1} contains the DOS partition
number, and @samp{part2} and @samp{part3} are both 0xFF. As another
example, if a disk is partitioned first into DOS partitions, and then
one of those DOS partitions is subdivided into several BSD partitions
using BSD's @dfn{disklabel} strategy, then @samp{part1} contains the DOS
partition number, @samp{part2} contains the BSD sub-partition within
that DOS partition, and @samp{part3} is 0xFF.

剩下的三个字节指出了引导分区。part1指出了顶级分区号，part2指出了顶级分区
中的一个子分区，等等。分区号总是从0开始。不使用的分区字节必须被设置为0xFF。
例如，如果磁盘被简单的分为单一的一层DOS分区，则part1包含这个DOS分区号，
part2和part3都是0xFF。另一个例子是，如果一个磁盘首先被分为DOS分区，并且其中
的一个DOS分区又被分为几个使用BSD磁盘标签策略的BSD分区，则part1包含DOS分区号，
part2包含DOS分区内的BSD分区号，part3则是0xFF。

DOS extended partitions are indicated as partition numbers starting from
4 and increasing, rather than as nested sub-partitions, even though the
underlying disk layout of extended partitions is hierarchical in
nature. For example, if the boot loader boots from the second extended
partition on a disk partitioned in conventional DOS style, then
@samp{part1} will be 5, and @samp{part2} and @samp{part3} will both be
0xFF.

DOS扩展分区的分区号从4开始，而不是像嵌套子分区一样，尽管扩展分区的底层分布
就是分层嵌套的。例如，如果引导程序从传统的DOS风格磁盘的第二个分区启动，则
part1是5，part2和part3都是0xFF。

If bit 2 of the @samp{flags} longword is set, the @samp{cmdline} field
is valid, and contains the physical address of the command line to
be passed to the kernel. The command line is a normal C-style
zero-terminated string. The exact format of command line is left to
OS developpers. General-purpose boot loaders should allow user a complete
control on command line independently of other factors like image name.
Boot loaders with specific payload in mind may completely or partially generate
it algorithmically.

如果设置了flags longword的第2位，则cmdline域是有效的，并且包含要传递
给内核的命令行参数的物理地址。命令行参数是一个正常C风格的以0终止的字符串。
命令行参数的具体格式留给操作系统的开发者决定。通用引导程序应该允许用户完全
控制命令行，独立于像镜像名称这样的其它因素。含有具体有效载荷引导装载程序
可以完全或部分通过算法生成它。


If bit 3 of the @samp{flags} is set, then the @samp{mods} fields
indicate to the kernel what boot modules were loaded along with the
kernel image, and where they can be found. @samp{mods_count} contains
the number of modules loaded; @samp{mods_addr} contains the physical
address of the first module structure. @samp{mods_count} may be zero,
indicating no boot modules were loaded, even if bit 3 of @samp{flags} is
set. Each module structure is formatted as follows:

如果设置了flags的第3位，则mods域指出了同内核一同载入的有哪些引导模块，以及
他们在哪里能找到他们。mods_count包含了需要加载的模块的个数；mods_addr包含了
第一个模块结构的物理地址。mods_count可以是0，这表示没有载入任何模块，即使
设置了flags的第3位时也可能是这样。每个模块的结构的格式如下：

@example
@group
        +-------------------+
0       | mod_start         |
4       | mod_end           |
        +-------------------+
8       | string            |
        +-------------------+
12      | reserved (0)      |
        +-------------------+
@end group
@end example

The first two fields contain the start and end addresses of the boot
module itself. The @samp{string} field provides an arbitrary string to
be associated with that particular boot module; it is a zero-terminated
ASCII string, just like the kernel command line. The @samp{string} field
may be 0 if there is no string associated with the module. Typically the
string might be a command line (e.g. if the operating system treats boot
modules as executable programs), or a pathname (e.g. if the operating
system treats boot modules as files in a file system), but its exact use
is specific to the operating system. The @samp{reserved} field must be
set to 0 by the boot loader and ignored by the operating system.

前两个域包含了引导模块的开始和结束地址。string域提供了一个自定义的与引导模块
相关的字符串；它是一个以0终止的ASCII字符串，同内核命令行参数一个。
如果没有什么与模块有关的字符串，string域可以是0。典型情况下，这个字符串也许是
命令行参数（例如，如果操作系统将引导程序视作可执行程序的话），或者一个路径名
（例如，如果操作系统将引导程序视作文件系统中的文件的话），它的意义取决于操作系统。
reserved域必须由引导程序设为0并被操作系统忽略。

@strong{Caution:} Bits 4 & 5 are mutually exclusive.

@strong{注意:} 第4位和第5位是互斥的。

If bit 4 in the @samp{flags} word is set, then the following fields in
the Multiboot information structure starting at byte 28 are valid:

如果设置了flags的第4位，则下面从Multiboot信息结构的第28位开始的域是有效的：


@example
@group
        +-------------------+
28      | tabsize           |
32      | strsize           |
36      | addr              |
40      | reserved (0)      |
        +-------------------+
@end group
@end example

These indicate where the symbol table from an a.out kernel image can be
found. @samp{addr} is the physical address of the size (4-byte unsigned
long) of an array of a.out format @dfn{nlist} structures, followed
immediately by the array itself, then the size (4-byte unsigned long) of
a set of zero-terminated @sc{ascii} strings (plus sizeof(unsigned long) in
this case), and finally the set of strings itself. @samp{tabsize} is
equal to its size parameter (found at the beginning of the symbol
section), and @samp{strsize} is equal to its size parameter (found at
the beginning of the string section) of the following string table to
which the symbol table refers. Note that @samp{tabsize} may be 0,
indicating no symbols, even if bit 4 in the @samp{flags} word is set.

这指出在哪里可以找到a.out格式内核映像的符号表。addr是a.out格式的nlist
结构数组的大小（4字节无符号长整数）的物理地址，紧接着是数组本身，然后是
一系列以0终止的ASCII字符串的大小（4字节无符号长整数，加上sizeof（unsigned long））
，然后是字符串本身。tabsize等于符号表的大小参数（位于符号section的头部），
strsize等于符号表指向的字符串的大小参数（位于string section的头部）。
注意，tabsize可以是0，这意味着没有符号，尽管已经设置了flags的第4位。

If bit 5 in the @samp{flags} word is set, then the following fields in
the Multiboot information structure starting at byte 28 are valid:

如果设置了flags的第5位，则下面从Multiboot信息结构的第28位开始的域是有效的：
@example
@group
        +-------------------+
28      | num               |
32      | size              |
36      | addr              |
40      | shndx             |
        +-------------------+
@end group
@end example

These indicate where the section header table from an ELF kernel is, the
size of each entry, number of entries, and the string table used as the
index of names. They correspond to the @samp{shdr_*} entries
(@samp{shdr_num}, etc.) in the Executable and Linkable Format (@sc{elf})
specification in the program header. All sections are loaded, and the
physical address fields of the @sc{elf} section header then refer to where
the sections are in memory (refer to the i386 @sc{elf} documentation for
details as to how to read the section header(s)). Note that
@samp{shdr_num} may be 0, indicating no symbols, even if bit 5 in the
@samp{flags} word is set.

这指出在哪里可以找到ELF格式内核映像的section头表、每项的大小、一共有几项
以及作为名字索引的字符串表。他们对应于可执行可链接格式（ELF）的程序头中
的shdr_*项（shdr_num等）。所有的section都会被载入，ELF section头的物理地址
域指向所有的section在内存的位置（参见i386 ELF文档可以得到如何读取section头
的更多的细节）。注意，shdr_num可以是0，标志着没有符号，尽管已经设置了flags
的第5位。


If bit 6 in the @samp{flags} word is set, then the @samp{mmap_*} fields
are valid, and indicate the address and length of a buffer containing a
memory map of the machine provided by the @sc{bios}. @samp{mmap_addr} is
the address, and @samp{mmap_length} is the total size of the buffer. The
buffer consists of one or more of the following size/structure pairs
(@samp{size} is really used for skipping to the next pair):


如果设置了flags的第6位，则mmap_*域是有效的，指出保存有BIOS提供的内存分布的
缓冲区的地址和长度。mmap_addr是缓冲区的地址，mmap_length是缓冲区的总大小。
缓冲区有一个或者多个下面的大小/结构对（size实际上是用来跳过下一个对的）组成的：

@example
@group
        +-------------------+
-4      | size              |
        +-------------------+
0       | base_addr         |
8       | length            |
16      | type              |
        +-------------------+
@end group
@end example

where @samp{size} is the size of the associated structure in bytes, which
can be greater than the minimum of 20 bytes. @samp{base_addr} is the
starting address. @samp{length} is the size of the memory region in bytes.
@samp{type} is the variety of address range represented, where a
value of 1 indicates available @sc{ram}, value of 3 indicates usable memory
holding ACPI information, value of 4 indicates reserved memory which needs to
be preserved on hibernation, value of 5 indicates a memory which is occupied by defective RAM modules and all other values currently
indicated a reserved area.

size是相关结构的大小，单位是字节，它可能大于最小值20。base_addr是起始地址，
length是内存区域大小。type是相应地址区间的类型，1代表可用ram，3代表可用内存
保存ACPI信息，4代表需要为休眠保留的内存，5代表这是由缺陷内存模块占用的内存。
所有其它的值代表保留区域。


The map provided is guaranteed to list all standard @sc{ram} that should
be available for normal use.

可以保证所提供的内存分布列出了所有可供正常使用的标准内存。

If bit 7 in the @samp{flags} is set, then the @samp{drives_*} fields
are valid, and indicate the address of the physical address of the first
drive structure and the size of drive structures. @samp{drives_addr}
is the address, and @samp{drives_length} is the total size of drive
structures. Note that @samp{drives_length} may be zero. Each drive
structure is formatted as follows:


如果设置了flags的第7位，则drives_*域是有效的，指出第一个驱动器的物理地址
和这个结构的大小。drives_addr是地址，drives_length是驱动器结构的总大小。
注意drives_length可以是0。每个驱动器结构的格式如下：

@example
@group
        +-------------------+
0       | size              |
        +-------------------+
4       | drive_number      |
        +-------------------+
5       | drive_mode        |
        +-------------------+
6       | drive_cylinders   |
8       | drive_heads       |
9       | drive_sectors     |
        +-------------------+
10 - xx | drive_ports       |
        +-------------------+
@end group
@end example

The @samp{size} field specifies the size of this structure. The size
varies, depending on the number of ports. Note that the size may not be
equal to (10 + 2 * the number of ports), because of an alignment.

size域指出了结构的大小，依据端口的数量，这个大小可能变化。注意，这个大小
可能不等于（10+2*端口的数量），这是由于对齐的原因。

The @samp{drive_number} field contains the BIOS drive number. The
@samp{drive_mode} field represents the access mode used by the boot
loader. Currently, the following modes are defined:

drive_number域包含BIOS驱动器号，drive_mode域代表了引导程序使用的访问模式，目前，
定义了如下的模式：

@table @samp
@item 0
CHS mode (traditional cylinder/head/sector addressing mode).
CHS 模式（传统的“柱面/磁头/扇区”寻址模式）。
@item 1
LBA mode (Logical Block Addressing mode).
LBA 模式（逻辑块寻址模式）。
@end table

The three fields, @samp{drive_cylinders}, @samp{drive_heads} and
@samp{drive_sectors}, indicate the geometry of the drive detected by the
@sc{bios}. @samp{drive_cylinders} contains the number of the
cylinders. @samp{drive_heads} contains the number of the
heads. @samp{drive_sectors} contains the number of the sectors per
track.

@samp{drive_cylinders}, @samp{drive_heads} 和 @samp{drive_sectors}这三个域指出
了BIOS检测到的驱动器参数。@samp{dirve_cylinders}包含柱面数，@samp{drive_heads}
包含磁头数，@samp{drive_sectors}包含每磁道的扇区数。

The @samp{drive_ports} field contains the array of the I/O ports used
for the drive in the @sc{bios} code. The array consists of zero or more
unsigned two-bytes integers, and is terminated with zero. Note that the
array may contain any number of I/O ports that are not related to the
drive actually (such as @sc{dma} controller's ports).

drive_ports域包含了BIOS代码使用的I/O端口的数组，这个数组包含了0个或者多个无符号
两字节整数，并且以0终止。注意，数组中可能包含任何实际上与驱动器不相关的I/O端口
（例如DMA控制器端口）。

If bit 8 in the @samp{flags} is set, then the @samp{config_table} field
is valid, and indicates the address of the @sc{rom} configuration table
returned by the @dfn{GET CONFIGURATION} @sc{bios} call. If the @sc{bios}
call fails, then the size of the table must be @emph{zero}.

如果设置了flags中的第8位，则config_table域是有效的，它指出了由@dfn{GET CONFIGURATION}
BIOS调用返回的ROM配置表的地址。如果这个BIOS调用失败了，这个表的大小
必须是0。


If bit 9 in the @samp{flags} is set, the @samp{boot_loader_name} field
is valid, and contains the physical address of the name of a boot
loader booting the kernel. The name is a normal C-style zero-terminated
string.


如果设置了flags域中的第9位，则boot_loader_name域是有效的，并且包含了引导程序
名字在物理内存中的地址，引导程序的名字是正常的C风格的以0终止的字符串。


If bit 10 in the @samp{flags} is set, the @samp{apm_table} field is
valid, and contains the physical address of an @sc{apm} table defined as
below:


如果设置了flags的第10位，则apm_table域是有效的。并且包含了如下apm表的物理地址：

@example
@group
        +----------------------+
0       | version              |
2       | cseg                 |
4       | offset               |
8       | cseg_16              |
10      | dseg                 |
12      | flags                |
14      | cseg_len             |
16      | cseg_16_len          |
18      | dseg_len             |
        +----------------------+
@end group
@end example

The fields @samp{version}, @samp{cseg}, @samp{offset}, @samp{cseg_16},
@samp{dseg}, @samp{flags}, @samp{cseg_len}, @samp{cseg_16_len},
@samp{dseg_len} indicate the version number, the protected mode 32-bit
code segment, the offset of the entry point, the protected mode 16-bit
code segment, the protected mode 16-bit data segment, the flags, the
length of the protected mode 32-bit code segment, the length of the
protected mode 16-bit code segment, and the length of the protected mode
16-bit data segment, respectively. Only the field @samp{offset} is 4
bytes, and the others are 2 bytes. See
@uref{http://www.microsoft.com/hwdev/busbios/amp_12.htm, Advanced Power
Management (APM) BIOS Interface Specification}, for more information.


域version、cseg、offset、cseg_16、dseg、flags、cseg_len、cseg_16_len、dseg_len分别
指出了版本号、保护模式32位代码段、入口点的偏移量、保护模式16位代码段、保护模式16位
数据段、标志位、保护模式32位代码段的长度、保护模式16位代码段的长度和保护模式16位数
据段的长度。只有offset域是4字节，其余的域都是2字节。
参见高级电源管理（APM）BIOS接口规范，获得更多信息。


If bit 11 in the @samp{flags} is set, the @sc{vbe} table is available.

如果设置了flags的第11位，则vbe表是可见的。

The fields @samp{vbe_control_info} and @samp{vbe_mode_info} contain
the physical addresses of @sc{vbe} control information returned by the
@sc{vbe} Function 00h and @sc{vbe} mode information returned by the
@sc{vbe} Function 01h, respectively.

域vbe_control_info和vbe_mode_info分别包含由VBE函数00h返回的VBE控制信息
的物理地址和由VBE函数01h返回的VBE模式信息。

The field @samp{vbe_mode} indicates current video mode in the format
specified in @sc{vbe} 3.0.

域vbe_mode指出了当前的显示模式，其中的信息符合VBE 3.0标准。

The rest fields @samp{vbe_interface_seg}, @samp{vbe_interface_off}, and
@samp{vbe_interface_len} contain the table of a protected mode interface
defined in @sc{vbe} 2.0+. If this information is not available, those
fields contain zero. Note that @sc{vbe} 3.0 defines another protected
mode interface which is incompatible with the old one. If you want to
use the new protected mode interface, you will have to find the table
yourself.

其余的域vbe_interface_seg、vbe_interface_off和vbe_interface_len包含了
VBE 2.0+中定义的保护模式接口。如果没有这些信息，这些域都是0 。注意VBE 3.0
定义了另一个保护模式接口，它与以前的版本是兼容的。如果你想要使用这
些新的保护模式接口，你必须自己找到这个表。

The fields for the graphics table are designed for @sc{vbe}, but
Multiboot boot loaders may simulate @sc{vbe} on non-@sc{vbe} modes, as
if they were @sc{vbe} modes.

graphics table中的域是按照VBE设计的，但是Multiboot引导程序可以在非VBE模式下模拟VBE模式。

If bit 12 in the @samp{flags} is set, the @sc{Framebuffer} table is available.

如果设置了flags域的第12位，则Framebuffer表是可见的。

The field @samp{framebuffer_addr} contains framebuffer physical address. This
field is 64-bit wide but bootloader @dfn{should} set it under 4 GiB if possible
for compatibility with kernels which aren't aware of PAE or AMD64. The field
@samp{framebuffer_pitch} contains the framebuffer pitch in bytes. The fields
@samp{framebuffer_width}, @samp{framebuffer_height} contain the framebuffer
dimensions in pixels. The field @samp{framebuffer_bpp} contains the number of
bits per pixel. If @samp{framebuffer_type} is set to @samp{0} it means
indexed color will be used. In this case color_info is defined as follows:

framebuffer_addr域包含了framebuffer的物理地址。该字段是64位宽度，但是如果可能的
话引导程序应该将其设置在4GiB以下，这是为了兼容那些不了解PAE或者AMD64的内核。
域framebuffer_pitch包含以字节为单位的帧缓冲间距。域framebuffer_width，framebuffer_height
包含了以像素为单位的帧缓冲区尺寸。  域framebuffer_bpp包含了每个像素的比特数。
如果域framebuffer_type设置为0，则表示索引颜色将被使用，在这种情况下，颜色信息的
定义如下：


@example
@group
        +----------------------------------+
110     | framebuffer_palette_addr         |
114     | framebuffer_palette_num_colors   |
        +----------------------------------+
@end group
@end example
@samp{framebuffer_palette_addr} contains the address of the color palette,
which is an array of color descriptors. Each color descriptor has the
following structure:

域framebuffer_palette_addr包含了调色版的地址，它是颜色描述符的数组的地址，
每种颜色描述符具有如下结构：

@example
@group
        +-------------+
0       | red_value   |
1       | green_value |
2       | blue_value  |
        +-------------+
@end group
@end example
If @samp{framebuffer_type} is set to @samp{1} it means direct RGB color will
be used. Then color_type is defined as follows:


如果域framebuffer_type设置为1，意味着直接RGB颜色将被使用，color_type的定义如下：

@example
@group
        +----------------------------------+
110     | framebuffer_red_field_position   |
111     | framebuffer_red_mask_size        |
112     | framebuffer_green_field_position |
113     | framebuffer_green_mask_size      |
114     | framebuffer_blue_field_position  |
115     | framebuffer_blue_mask_size       |
        +----------------------------------+
@end group
@end example

If @samp{framebuffer_type} is set to @samp{2} it means EGA-standard text mode
will be used. In this case @samp{framebuffer_width} and
@samp{framebuffer_height} are expressed in characters instead of pixels.
@samp{framebuffer_bpp} is equal to 16 (bits per character) and
@samp{framebuffer_pitch} is expressed in bytes per text line.
All further values of @samp{framebuffer_type} are reserved for future expansion.

如果framebuffer_type域被设置为2，这意味着EGA标准的文本模式将被使用。在这种情况下
域framebuffer_width和framebuffer_height以字符为单位而不是像素。域framebuffer_bpp
等于16（每个字符的位数），域framebuffer_pitch表示每个文本行的字节数。

framebuffer_type域的其它所有值，为将来的扩展保留。

@node Examples
@chapter Examples

@strong{Caution:} The following items are not part of the specification
document, but are included for prospective operating system and boot
loader writers.

@strong{注意：} Multiboot规范并不包含下面的部分，但是下面章节的内容可以
为未来的操作系统和启动程序的作者提供参考。

@menu
* Notes on PC::                 
* BIOS device mapping techniques::  
* Example OS code::             
* Example boot loader code::    
@end menu


@node Notes on PC
@section Notes on PC

In reference to bit 0 of the @samp{flags} parameter in the Multiboot
information structure, if the bootloader in question uses older
@sc{bios} interfaces, or the newest ones are not available (see
description about bit 6), then a maximum of either 15 or 63 megabytes of
memory may be reported. It is @emph{highly} recommended that boot
loaders perform a thorough memory probe.

在使用Multiboot信息结构中flags域中的第0位时，如果使用的引导程序使用较老
的BIOS接口，或者还不被支持的最新的接口（参见有关第6位的描述），则返回的
内存大小可能是15或者63M。因此，强烈推荐引导程序进行彻底的内存检查。

In reference to bit 1 of the @samp{flags} parameter in the Multiboot
information structure, it is recognized that determination of which
@sc{bios} drive maps to which device driver in an operating system is
non-trivial, at best. Many kludges have been made to various operating
systems instead of solving this problem, most of them breaking under
many conditions. To encourage the use of general-purpose solutions to
this problem, there are 2 @sc{bios} device mapping techniques
(@pxref{BIOS device mapping techniques}). 

在使用Multiboot信息结构中flags域中的第1位时,我们发现在最好的情况下，将
哪个BIOS驱动器映射到哪个操作系统的设备驱动的决定也不容易作出。不同的操作
系统提出了许多笨拙的 办法来解决这个问题，但是大多数在很多情况下都会失败。
为了鼓励使用通用的方法来解决这个问题，我们提出来了2种BIOS设备映射技术
（参加@pxref{BIOS device mapping techniques}）。

In reference to bit 6 of the @samp{flags} parameter in the Multiboot
information structure, it is important to note that the data structure
used there (starting with @samp{BaseAddrLow}) is the data returned by
the INT 15h, AX=E820h --- Query System Address Map call. See @xref{Query
System Address Map, , Query System Address Map, grub.info, The GRUB
Manual}, for more information. The interface here is meant to allow a
boot loader to work unmodified with any reasonable extensions of the
@sc{bios} interface, passing along any extra data to be interpreted by
the operating system as desired.

在使用Mulitboot信息结构中flags域的第6位时，一定要注意这里用到的数据结构
（自@samp{BaseAddrLow}开始），该数据是由INT 15h，AX=E820h返回的数据——查询
系统地址映射调用。获取更多信息，请参见 @xref{Query System Address Map, ,
Query System Address Map, grub.info, The GRUB Manual},这里的接口用来使
一个引导程序可以不用修改的同进行过合理扩展的BIOS接口共同的工作，这些
扩展只是给予操作系统期望的更多的信息。


@node BIOS device mapping techniques
@section BIOS device mapping techniques

Both of these techniques should be usable from any PC operating system,
and neither require any special support in the drivers themselves. This
section will be flushed out into detailed explanations, particularly for
the I/O restriction technique.

这两个技术可以用于任何的PC操作系统，并且也不需要驱动程序本身提供任何的特殊
支持。本节将大量的讨论细节问题，尤其是IO限制技术。

The general rule is that the data comparison technique is the quick and
dirty solution. It works most of the time, but doesn't cover all the
bases, and is relatively simple.

通用的规则是数据比较技术，它是快速但丑陋的方案。它在大多数情况下工作正常，
但是并不总是这样，不过它相对简单。

The I/O restriction technique is much more complex, but it has potential
to solve the problem under all conditions, plus allow access of the
remaining @sc{bios} devices when not all of them have operating system
drivers.

I/O限制技术要复杂的多，但它更有可能在所有情况下解决问题，另外，还允许
在并非所有的BIOS设备拥有操作系统的驱动程序时访问有驱动程序的BIOS设备。


@menu
* Data comparison technique::   
* I/O restriction technique::   
@end menu


@node Data comparison technique
@subsection Data comparison technique

Before activating @emph{any} of the device drivers, gather enough data
from similar sectors on each of the disks such that each one can be
uniquely identified.

在激活任何设备驱动程序之前，要从每个磁盘上的相似扇区中收集足够的数据，
这样就可以区分每一个扇区。

After activating the device drivers, compare data from the drives using
the operating system drivers. This should hopefully be sufficient to
provide such a mapping.

在激活了设备驱动程序后，使用操作系统驱动比较不同驱动器的数据。这样就可以
为映射提供足够的信息。

Problems:

问题：

@enumerate
@item
The data on some @sc{bios} devices might be identical (so the part
reading the drives from the @sc{bios} should have some mechanism to give
up).

一些BIOS设备上的数据可能是相同的（所以从BIOS读取设备信息的方法可能失败）。

@item
There might be extra drives not accessible from the @sc{bios} which are
identical to some drive used by the @sc{bios} (so it should be capable
of giving up there as well).

可能有一些BIOS不可访问的设备同BIOS用到的设备相同（所以这时这个方法也
可能宣告失败）。
@end enumerate


@node I/O restriction technique
@subsection I/O restriction technique

This first step may be unnecessary, but first create copy-on-write
mappings for the device drivers writing into @sc{pc} @sc{ram}. Keep the
original copies for the @dfn{clean @sc{bios} virtual machine} to be
created later.

第一步并不是必要的，但首先为设备驱动程序创建copy-on-wrire映射。随后创建
洁净BIOS虚拟机的原始拷贝。

For each device driver brought online, determine which @sc{bios} devices
become inaccessible by:

对于每一个设备驱动程序，决定哪个BIOS不可访问，方法是：


@enumerate
@item
Create a @dfn{clean @sc{bios} virtual machine}.

创建一个洁净的BIOS虚拟机。

@item
Set the I/O permission map for the I/O area claimed by the device driver
to no permissions (neither read nor write).

将设备驱动程序要求的I/O区域在I/O允许位图中设置为无权限（即不能写也不能读）。

@item
Access each device.

访问每一个设备。

@item
Record which devices succeed, and those which try to access the
@dfn{restricted} I/O areas (hopefully, this will be an @dfn{xor}
situation).

记录哪些设备访问成功，以及哪些试图访问受限I/O区域（这将可能是一个xor情景）
@end enumerate

For each device driver, given how many of the @sc{bios} devices were
subsumed by it (there should be no gaps in this list), it should be easy
to determine which devices on the controller these are.

对于每个设备驱动程序，假设已知其中有多少个BIOS设备（这个表中应该没有缝隙），
应该很容易的确定哪些设备受这些控制器控制。

In general, you have at most 2 disks from each controller given
@sc{bios} numbers, but they pretty much always count from the lowest
logically numbered devices on the controller.

通常，每个拥有BIOS号的控制器上你至少有两个磁盘，他们总是从控制器逻辑号
最低的设备数起。

@node Example OS code
@section Example OS code

In this distribution, the example Multiboot kernel @file{kernel} is
included. The kernel just prints out the Multiboot information structure
on the screen, so you can make use of the kernel to test a
Multiboot-compliant boot loader and for reference to how to implement a
Multiboot kernel. The source files can be found under the directory
@file{doc} in the Multiboot source distribution.

在这个发行版本中，包括了示例Multiboot内核kernel。这个内核只是在屏幕上
输出Multiboot信息结构，所以你可以利用这个内核检测一个Multiboot兼容的
引导程序，或者作为如何实现一个Multiboot兼容的内核的参考。源文件可以在
Multiboot发行版本的doc目录中找到。

The kernel @file{kernel} consists of only three files: @file{boot.S},
@file{kernel.c} and @file{multiboot.h}. The assembly source
@file{boot.S} is written in GAS (@pxref{Top, , GNU assembler, as.info,
The GNU assembler}), and contains the Multiboot information structure to
comply with the specification. When a Multiboot-compliant boot loader
loads and execute it, it initialize the stack pointer and @code{EFLAGS},
and then call the function @code{cmain} defined in @file{kernel.c}. If
@code{cmain} returns to the callee, then it shows a message to inform
the user of the halt state and stops forever until you push the reset
key. The file @file{kernel.c} contains the function @code{cmain},
which checks if the magic number passed by the boot loader is valid and
so on, and some functions to print messages on the screen. The file
@file{multiboot.h} defines some macros, such as the magic number for the
Multiboot header, the Multiboot header structure and the Multiboot
information structure.

内核kernel仅有3个文件组成：boot.S,kernel.c和multiboot.h。汇编源代码boot.S
使用GAS汇编格式，包含符合本规范的Multiboot信息结构。当一个Multiboot兼容的引导
程序载入并执行它时，它初始化堆栈指针和@code{EFLAGS}，然后调用kernel.c中
定义的函数cmain。如果cmain返回，则它显示一条信息通知用户进入停机状态
并停止执行直到你按下reset键。文件kernel.c包含函数cmain，它检查引导程序
传递过来的魔数是否有效等等，以及一些向屏幕输出消息的函数。文件Multiboot.h定义了
一些宏，如Multiboot头的魔数，Multiboot头结构和Multiboot信息结构等。

@menu
* multiboot.h::                 
* boot.S::                      
* kernel.c::                    
* Other Multiboot kernels::     
@end menu


@node multiboot.h
@subsection multiboot.h

This is the source code in the file @file{multiboot.h}:

这是文件@file{multiboot.h}中的源代码：

@example
@include multiboot.h.texi
@end example


@node boot.S
@subsection boot.S

In the file @file{boot.S}:

这是文件@file{boot.S}中的源代码：

@example
@include boot.S.texi
@end example


@node kernel.c
@subsection kernel.c

And, in the file @file{kernel.c}:

这是文件@file{kernel.c}中的源代码：

@example
@include kernel.c.texi
@end example


@node Other Multiboot kernels
@subsection Other Multiboot kernels

Other useful information should be available in Multiboot kernels, such
as GNU Mach and Fiasco @url{http://os.inf.tu-dresden.de/fiasco/}. And,
it is worth mentioning the OSKit
@url{http://www.cs.utah.edu/projects/flux/oskit/}, which provides a
library supporting the specification.


@node Example boot loader code
@section Example boot loader code

The GNU GRUB (@pxref{Top, , GRUB, grub.info, The GRUB manual}) project
is a Multiboot-compliant boot loader, supporting all required and
many optional features present in this specification. A public release has
not been made, but the test release is available from:

@url{ftp://alpha.gnu.org/gnu/grub}

GNU GRUN (@pxref{Top, , GRUB, grub.info, The GRUB manual})项目是一个Multiboot
兼容的boot loader，它支持该规范中所有必须的和
和大多数可选的特征。它还没有发布正式版，但是其测试版本的地址如下：

@url{ftp://alpha.gnu.org/gnu/grub}

See the webpage @url{http://www.gnu.org/software/grub/grub.html}, for
more information.


可以从其网页上 @url{http://www.gnu.org/software/grub/grub.html}, 获得更多信息。


@node History
@chapter The change log of this specification

@table @asis
@item 0.7
@itemize @bullet
@item
@dfn{Multiboot Standard} is renamed to @dfn{Multiboot Specification}.

@item
Graphics fields are added to Multiboot header.

@item
BIOS drive information, BIOS configuration table, the name of a boot
loader, APM information, and graphics information are added to Multiboot
information.

@item
Rewritten in Texinfo format.

@item
Rewritten, using more strict words.

@item
The maintainer changes to the GNU GRUB maintainer team
@email{bug-grub@@gnu.org}, from Bryan Ford and Erich Stefan Boleyn.

@item
The byte order of the @samp{boot_device} in Multiboot information is
reversed. This was a mistake.

@item
The offset of the address fields were wrong.

@item
The format is adapted to a newer Texinfo, and the version number is
specified more explicitly in the title.
@end itemize

@item 0.6
@itemize @bullet
@item
A few wording changes.

@item
Header checksum.

@item
Classification of machine state passed to an operating system.
@end itemize

@item 0.5
@itemize @bullet
@item
Name change.
@end itemize

@item 0.4
@itemize @bullet
@item
Major changes plus HTMLification.
@end itemize
@end table

@node Invoking mbchk
@chapter Invoking mbchk

关于程序 mbchk

The program @command{mbchk} checks for the format of a Multiboot
kernel. We recommend using this program before booting your own kernel.

程序@command{mbchk}检查一个内核是否是Multiboot兼容的。我们推荐在启动
你自己的内核前使用该程序。

@command{mbchk} accepts the following options:

@command{mbchk} 接受如下选项参数：

@table @option
@item --help
Print a summary of the command-line options and exit.

打印命令选项参数的说明总结并且退出。

@item --version
Print the version number of GRUB and exit.

打印GRUB的版本号并退出。

@item --quiet
Suppress all normal output.

禁止一起正常的输出。
@end table



@node Index
@unnumbered Index

@printindex cp

@contents
@bye
